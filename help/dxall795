#!F-adobe-helvetica-medium-r-normal--18*
#!N 
#!N  #!Rcompute Compute #!N #!N Category #!N #!N  #!Lcattrn,dxall763 h Transformation  #!EL  #!N 
#!N Function #!N #!N Evaluates an expression on each data point 
in a specified field or value list. #!N #!N Syntax #!CForestGreen 
#!N #!N  #!F-adobe-courier-bold-r-normal--18*    #!F-adobe-times-bold-r-normal--18*   #!N output #!EF = Compute(  #!F-adobe-times-bold-r-normal--18*   expression, 
input, ... #!EF ); #!EF #!N #!N #!EC #!N #!N Inputs 
#!T,1,91,276,461,646  #!F-adobe-times-medium-r-normal--14*    #!F-adobe-times-bold-r-normal--18*   #!N TAB Name TAB Type TAB Default TAB 
Description #!EF #!N TAB expression TAB string TAB none TAB expression 
to be computed #!N TAB input TAB field or value list 
TAB no default TAB input value #!N TAB ... TAB ... 
TAB ... TAB more input values #!N TAB - TAB - 
TAB - TAB #!EF #!N #!N Outputs #!T,1,161,321,646  #!F-adobe-times-medium-r-normal--14*    #!F-adobe-times-bold-r-normal--18*   #!N 
TAB Name TAB Type TAB Description #!EF #!N TAB output TAB 
field, value, or value list TAB output values #!N TAB - 
TAB - TAB #!EF #!N #!N Functional Details #!N #!N This 
module applies an expression to every data value in a field. 
#!N #!I0 #!N #!N #!I0 #!N  #!F-adobe-times-bold-r-normal--18*    #!F-adobe-times-bold-r-normal--18*   expression #!EF #!EF 
#!I50 #!N is the mathematical expression to be applied to  #!F-adobe-times-bold-r-normal--18*   
input #!EF .  #!Loper14,dxall795 t Table 14  #!EL  lists the operators. #!N #!I0 #!N  #!F-adobe-times-bold-r-normal--18*   
 #!F-adobe-times-bold-r-normal--18*   input #!EF #!EF #!I50 #!N is the field or value 
list to which  #!F-adobe-times-bold-r-normal--18*   expression #!EF is to be applied. If 
there are more than one, the input fields must be isomorphic 
(i.e., their hierarchies must match exactly). #!I0 #!N #!N A single 
Compute module can operate on a maximum of 21  #!F-adobe-times-bold-r-normal--18*   input 
#!EF values. In the user interface, the default number of enabled 
input tabs is two. The default number of enabled input tabs 
is two. (Tabs can be added to the module icon and 
removed with the appropriate  #!F-adobe-times-bold-r-normal--18*   ...Input Tab #!EF options in the 
 #!F-adobe-times-bold-r-normal--18*   Edit #!EF pull-down menu of the VPE.) #!N #!N In 
the user interface, variables have names and  #!F-adobe-times-bold-r-normal--18*   expression #!EF does 
not require quotation marks. If the vector variable is "sample," the 
vector elements are "sample.x," "sample.y," ... or "sample.0," "sample.1," .... #!N 
#!N In the scripting language, the parameters of an expression are 
indicated by $  #!F-adobe-times-medium-i-normal--18*   n #!EF , where  #!F-adobe-times-medium-i-normal--18*   n #!EF 
is the index of the parameter, and counting begins at 0. 
The first three components of a vector can be expressed by 
"  #!F-adobe-times-medium-i-normal--18*   .x #!EF ," "  #!F-adobe-times-medium-i-normal--18*   .y #!EF ," and 
"  #!F-adobe-times-medium-i-normal--18*   .z #!EF ," or by "  #!F-adobe-times-medium-i-normal--18*   .0 #!EF 
," "  #!F-adobe-times-medium-i-normal--18*   .1 #!EF ," and "  #!F-adobe-times-medium-i-normal--18*   .2 #!EF 
." The syntax for creating a vector from multiple inputs is 
[  #!F-adobe-times-medium-i-normal--18*   $0, $1, $2, ... #!EF ], where the commas 
separators are required. #!N #!N Thus, in the user interface the 
expression used to add the value 3 to every data value 
of the input field would be "a + 3.," while in 
the scripting language it would be "$0 + 3." #!N #!N 
Multiple expressions can be entered if they are separated by semicolons; 
the final expression is used as the output. For example, "temp=a.x; 
sin(temp)" is equivalent to "sin(a.x)." #!N #!N Compute uses C-language-style order 
of precedence for mathematical operations. #!N #!N Operations applied to invalid 
elements of fields typically result in invalid elements. (For more information, 
see  #!Linval,dxall211 h Invalid Positions and Invalid Connections Components  #!EL  .) For example, if at a particular element field 
 #!F-adobe-times-medium-i-normal--18*   "a" #!EF and  #!F-adobe-times-medium-i-normal--18*   "c" #!EF are valid, but field 
 #!F-adobe-times-medium-i-normal--18*   "b" #!EF is not,  #!F-adobe-times-medium-i-normal--18*   "a+b" #!EF is invalid, and 
 #!F-adobe-times-medium-i-normal--18*   "a? b: c" #!EF is valid only if  #!F-adobe-times-medium-i-normal--18*   "a" 
#!EF is 0; otherwise, it is invalid. An exception is the 
"invalid" function, which returns the integer 1 if the entry is 
invalid and 0 otherwise. #!N #!N Operations such as multiplying a 
vector by a scalar have the expected effect: each element of 
the vector is multiplied by the scalar. Likewise, the addition of 
two equal-length vectors or equal-size matrices results in an element-by-element sum. 
The Compute module defines the multiplication (  #!F-adobe-times-bold-r-normal--18*   * #!EF ) 
of two equal-length vectors as an element-by-element multiplication (as opposed to 
the dot product). Other operations, such as the sine of a 
vector, are defined similarly. #!N #!N Constants may be specified as 
double precision by using scientific notation with "d" indicating the exponent 
(e.g., 1d0 is double-precision 1). #!N #!N Note that you can 
convert a "ref" type invalid component (see  #!Linval,dxall211 h Invalid Positions and Invalid Connections Components  #!EL  in IBM Visualization 
Data Explorer User's Guide) using the expression "byte (invalid (a))." Then 
use Replace to substitute this new array into the original field 
as the "invalid positions" or "invalid connections" component. #!N #!N  #!Roper14 
#!T,1,41,366,646  #!F-adobe-times-bold-r-normal--18*   #!N TAB Table 14. Operators for the Compute Module 
#!N TAB Functions TAB Types of Operands #!EF #!N TAB Trigonometric 
Functions (argument in radians) TAB #!N TAB - TAB sin(a), cos(a), 
tan(a), asin(a), acos(a), atan(a), atan2(a, b) TAB float, double #!N TAB 
Hyperbolic Functions TAB #!N TAB - TAB sinh(a), cosh(a), tanh(a) TAB 
float, double #!N TAB Logarithmic Functions TAB #!N TAB - TAB 
log(a), In(a) (natural logarithm), log10(a) TAB #!N TAB - TAB (log 
base 10--see Note 1), exp(a) TAB float, double #!N TAB Unary 
Functions TAB #!N TAB - TAB +a, -a (negation) TAB any 
type #!N TAB Binary Functions TAB #!N TAB - TAB a+b, 
a-b, a*b, a/b, a%b (modulus--see Note 1), TAB #!N TAB - 
TAB a^b or a**b (exponentiation--see Note 4) TAB any type #!N 
TAB Vector Functions (see Note 1) TAB #!N TAB - TAB 
a dot b or dot(a, b) TAB float vector #!N TAB 
- TAB a cross b or cross(a,b) TAB float 3-vector #!N 
TAB - TAB mag(a) TAB double, float vector #!N TAB - 
TAB norm(a) TAB float vector #!N TAB Miscellaneous Functions TAB #!N 
TAB - TAB sqrt(a) TAB float, double, complex #!N TAB - 
TAB pow(a, b) (see Note 4) TAB float, double, complex #!N 
TAB - TAB abs(a) (see Note 2) TAB double, float, integer, 
complex #!N TAB - TAB arg(a) TAB complex only #!N TAB 
- TAB sign(a) TAB all real types #!N TAB - TAB 
min(a, b, ...), max(a, b, ...) TAB scalar #!N TAB - 
TAB invalid(a) (see Note 5) TAB any type #!N TAB - 
TAB random(a,seed) (see note 8) TAB produces random values in the 
#!N TAB - TAB - TAB range 0<=r<1 for each item 
in #!N TAB - TAB - TAB a. #!N TAB Type 
Manipulation Functions TAB #!N TAB - TAB int(a), float(a), byte(a), char(a), 
double(a), short(a), TAB float, integer, byte, #!N TAB - TAB sbyte, 
ubyte, ushort, uint (see Note 6) TAB short, double #!N TAB 
- TAB trunc(a), floor(a), ceil(a), rint(a) TAB float, double #!N TAB 
- TAB complex(a,b) or complex(a), TAB float, integer, byte, short, #!N 
TAB - TAB - TAB double #!N TAB - TAB real(a) 
TAB complex only #!N TAB - TAB imag(a) TAB complex only 
#!N TAB Vector Construction TAB #!N TAB - TAB [a, b, 
...] TAB any type #!N TAB Vector Selection Functions TAB #!N 
TAB - TAB a.x or a.0, a.y or a.1, and so 
on TAB vector #!N TAB - TAB select(a,b) (selects b(th) element 
of a, TAB #!N TAB - TAB where element is of 
rank r-1) TAB a is a vector, b is an integer 
#!N TAB Conditional Functions TAB #!N TAB - TAB a?b:c TAB 
a is an integer #!N TAB - TAB if a != 
0, then b, else c. (b and c must be of 
the same type.) Expressions b and c are TAB #!N TAB 
- TAB always evaluated, and the output value depends on the 
value of a. TAB #!N TAB Logical Operations TAB #!N TAB 
- TAB binary: <, >, <=, >= (true = 1; false 
= 0) TAB any scalar type #!N TAB - TAB binary: 
==, != TAB any type #!N TAB - TAB Unary: ! 
(not), binary: && (and), || (or) TAB integer #!N TAB Bitwise 
Operations TAB #!N TAB - TAB and(a,b), xor(a,b), or(a,b), not(a) (one's 
complement) TAB byte, int #!N TAB String functions (see Note 7) 
TAB #!N TAB - TAB strcmp(a,b) TAB strings #!N TAB - 
TAB compares strings a and b and returns 0 if a==b, 
a negative integer if a<b, and a TAB #!N TAB - 
TAB positive integer if a>b TAB #!N TAB - TAB stricmp 
is identical to strcmp except that it ignores case TAB #!N 
TAB - TAB strlen(a) TAB string #!N TAB - TAB returns 
the length of string a TAB #!N TAB - TAB strstr(a,b) 
TAB strings #!N TAB - TAB finds substring b in string 
a and returns 1-based offset of b in a. Thus TAB 
#!EF #!N TAB - TAB strstr('artist','art') = 1 strstr('artist','picasso') = 0 
strstr('monet','one') = 2 TAB #!N TAB - TAB stristr(a,b) is identical 
to strstr except that it ignores case TAB #!N TAB Notes: 
#!N TAB #!N TAB 1. The vector functions, modulus function, and 
log10() function do not accept complex numbers as arguments. #!N TAB 
#!N TAB 2. Given an integer or floating-point value, the abs() 
function yields the absolute value. Given a complex number, the abs() 
#!N TAB function yields a real absolute value. #!N TAB #!N 
TAB 3. If a string is passed as a parameter to 
Compute, it is treated as an array of bytes, with its 
values being the ASCII #!N TAB values of the string elements. 
#!N TAB #!N TAB 4. This function returns a floating-point value 
if inputs are floating point or integer. It returns a complex 
if the first #!N TAB input is complex. #!N TAB #!N 
TAB 5. Returns integer 1 if entity is marked invalid, and 
0 otherwise. #!N TAB #!N TAB 6. Byte and char are 
same as ubyte. #!N TAB #!N TAB 7. Strings can be 
passed into Compute as the data component or directly from String 
and StringList interactors. Strings can #!N TAB also be specified in 
the Compute expression directly by enclosing them in single quotes. A 
single quote character is #!N TAB represented by a pair of 
single quotes. Thus if a is the string "can't," then strcmp(a,'can''t') 
= 0. #!N TAB #!N TAB 8. The random number generator 
will be seeded by the integer seed. If a corresponds to 
a group then each member of a will be #!N TAB 
seeded by seed+n, where n corresponds to the member's enumerated location 
in a. This results in repeatable behavior even #!N TAB when 
a composite field is being processed in parallel on an SMP 
machine. To generate different random results, use a #!N TAB different 
seed. To operate on a component other than "data," use the 
Mark and Unmark modules together with Compute. #!N #!N A single 
Compute module can operate on a maximum of 21  #!F-adobe-times-bold-r-normal--18*   ...Input 
#!EF values. The default number of enabled input tabs is two. 
(Tabs can be added to the module icon and removed with 
the appropriate  #!F-adobe-times-bold-r-normal--18*   ...Input Tab #!EF options in the  #!F-adobe-times-bold-r-normal--18*   Edit 
#!EF pull-down menu of the VPE.) #!N Note: Other than a 
divide by zero, Compute operations are unchecked. #!N #!N #!N Components 
#!N #!N Modifies the "data" and "invalid positions" or "invalid connections" 
components. All other components are propagated to the output. #!N #!N 
Script Language Examples #!N #!I0 #!N  #!F-adobe-times-medium-r-normal--18*   #!N #!N #!I30 #!N 
1. The Compute module converts all the temperature data to Fahrenheit. 
#!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N tempf = Compute("$0*(9.0/5.0) + 32", tempc); 
#!N . . . #!EF #!N #!N #!EC #!N #!I30 #!N 
2. The input field is a vector field of dimension 9. 
The output field is scalar, consisting of the sixth component of 
the input field. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N new_field = Compute("$0.5",field); 
#!EF #!N #!N #!EC #!N #!I30 #!N 3. The input field 
is a vector field, and the output field is also a 
vector field, with the  #!F-adobe-times-medium-i-normal--18*   x #!EF component multiplied by 2. 
#!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N new_field = Compute("[2*$0.x, $0.y, $0.z]", field); 
#!EF #!N #!N #!EC  #!F-adobe-times-medium-i-normal--18*   or #!EF #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   
#!N new_field = Compute("[2, 1, 1]*$0", field); #!EF #!N #!N #!EC 
#!N #!I30 #!N 4. Here  #!F-adobe-times-bold-r-normal--18*   field1 #!EF is a vector 
field and  #!F-adobe-times-bold-r-normal--18*   field2 #!EF and  #!F-adobe-times-bold-r-normal--18*   field3 #!EF are scalar. 
Therefore, the output field will have a data component equal (on 
a point-by-point basis) to the magnitude of  #!F-adobe-times-bold-r-normal--18*   field1 #!EF added 
to the quantity  #!F-adobe-times-bold-r-normal--18*   field2 #!EF divided by 4.5 times  #!F-adobe-times-bold-r-normal--18*   
field3 #!EF . #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N new_field = Compute("mag($0) 
+ $1/($2*4.5)", field1, field2, field3); #!EF #!N #!N #!EC #!N #!I30 
#!N 5. The Mark module to place the "positions" component of 
the 2-dimensional object  #!F-adobe-times-bold-r-normal--18*   slice #!EF in the "data" component, allowing 
Compute to operate on the positions. The formula string is assigned 
to  #!F-adobe-times-bold-r-normal--18*   function #!EF to simplify the call to Compute and 
is equivalent to the following formula for converting  #!F-adobe-times-bold-r-normal--18*   slice #!EF 
positions to 2-dimensional vectors: #!N [ x, y, z] = [ 
sin( 2 pi x (x + 1) / 3.9 ) , 
y , - cos( 2 pi x (x + 1) / 
3.9 ) ] #!N When the computation is done, the Unmark 
module replaces the original "data" component for use in  #!F-adobe-times-bold-r-normal--18*   warped 
#!EF . The resulting positions are warped onto the shape of 
a cylinder. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N . . . #!N 
slice = Slice(electrondensity, "z", 5); #!N // Mark the positions so 
that they can be computed on #!N // The original x 
positions go from -1 to 2.9 #!N // The original y 
positions go from -3 to 2.9 #!N markedslice = Mark(slice,"positions"); #!N 
// Warp the positions onto the shape of a cylinder #!N 
pi = 3.14159; #!N exp = "[sin(2*$1*($0.x+1)/3.9), $0.y, -cos(2*$1*($0.x+1)/3.9)]"; #!N warped 
= Compute(exp, markedslice, pi); #!N // Unmark the warped positions, returning 
them to the positions #!N // component #!N warped = Unmark(warped, 
"positions"); #!N . . . #!EF #!N #!N #!EC #!N #!I30 
#!N 6. This example differs from the previous one in that 
the  #!F-adobe-times-bold-r-normal--18*   exp #!EF ) function warps the positions onto a 
double cone shape, by implementing the following formula: #!N [ x, 
y, z] = [ y x sin( 2 pi x (x 
+ 1) / 3.9 ) , y , - y x 
cos( 2 pi x (x + 1) / 3.9 ) ] 
#!N #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N . . . #!N // 
Now warp the positions onto the shape of a doubled cone 
#!N // by multiplying the x and z positions by the 
original #!N // y value, which goes from -3 to 2.9 
#!N exp = "[$0.y*sin(2*$1*($0.x+1)/3.9),$0.y, -$0.y*cos(2*$1*($0.x+1)/3.9)]"; #!N warped = Compute(exp, markedslice, pi); 
#!N // Unmark the warped positions, returning them to the positions 
#!N // component #!N warped = Unmark(warped, "positions"); #!N . . 
. #!EF #!N #!N #!EC #!N #!I0 #!N #!EF #!N #!N 
#!N Example Visual Programs #!N #!N Many of the example visual 
programs use Compute, including: #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N ComputeOnData.net #!N 
DataDrivenInteractors.net #!N PlotTwoLines.net #!N WarpingPositions.net #!EF #!N #!N #!EC #!N #!N 
See Also #!N #!N  #!Lmark,dxall893 h Mark  #!EL  ,  #!Lunmark,dxall972 h Unmark  #!EL  #!N #!N #!N  #!F-adobe-times-medium-i-normal--18*   
Next Topic #!EF #!N #!N  #!Lcomput2,dxall796 h Compute2  #!EL  #!N  #!F-adobe-times-medium-i-normal--18*   #!N 
