#!F-adobe-helvetica-medium-r-normal--18*
#!N 
#!CNavyBlue #!N  #!Rshowp ShowPick Module Example--Using Color to Show a 
Picked Object #!N #!EC #!N #!N #!N In the following example, 
the ShowPick module colors the entire object in white, except for 
the Field, element, or vertex containing the pick point(s). The color 
of the latter is specified by the user. #!N #!N The 
module description file for ShowPick is: #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 
MODULE ShowPick #!N CATEGORY User #!N DESCRIPTION sets a triangle in 
a picked Field to a particular color #!N INPUT input; object; 
(none); object with picked points #!N INPUT pickobject; field; (none); picking 
structure #!N INPUT color; string; "red"; color to set #!N INPUT 
colorwhich; integer; 0; color the element (0), vertex (1) or entire 
field (2) #!N INPUT poke; integer; (all); poke selection #!N INPUT 
pick; integer; (all); pick selection #!N INPUT depth; integer; (bottom); selection 
depth #!N OUTPUT output; object; object with picked structures marked using 
color #!EF #!N #!N #!EC #!N #!N As the  #!F-adobe-times-bold-r-normal--18*   .mdf 
#!EF file shows, the ShowPick module takes seven inputs and generates 
one output. To create a version of Data Explorer that includes 
this module, copy the following files to the directory where you 
want to work: #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N  #!F-adobe-times-bold-r-normal--18*   /usr/lpp/dx/samples/program_guide/Makefile_ #!EF 
 #!F-adobe-times-bold-i-normal--18*   supported workstation model #!EF #!N  #!F-adobe-times-bold-r-normal--18*   /usr/lpp/dx/samples/program_guide/showpick.c #!EF #!N  #!F-adobe-times-bold-r-normal--18*   
/usr/lpp/dx/samples/program_guide/showpick.mdf #!EF #!EF #!N #!N #!EC Now rename the makefile to 
 #!F-adobe-times-bold-r-normal--18*   Makefile #!EF and enter: make showpick. This command creates an 
executable that contains the ShowPick module. #!N #!N To invoke this 
version (from the directory to which the files were copied), enter: 
#!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N dx -edit -mdf ./showpick.mdf -exec ./dxexec 
#!EF #!N #!N #!EC This command starts Data Explorer (the  #!F-adobe-times-bold-r-normal--18*   
showpick.mdf #!EF file tells the graphical user interface about ShowPick and 
its inputs and outputs). With this version of Data Explorer you 
can now run any visual program that uses the ShowPick module. 
One such program is  #!F-adobe-times-bold-r-normal--18*   showpick.net #!EF in the  #!F-adobe-times-bold-r-normal--18*   /usr/lpp/dx/samples/program_guide 
#!EF directory. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 01 #include <dx/dx.h> #!N 
02 #include "pick.h" #!N 03 #!N 04 static Error DoPick(Object, Object, 
RGBColor, int, int, int, int); #!N 05 static Error SetColor(Object, RGBColor); 
#!N 06 #!N 07 Error m_ShowPick(Object *in, Object *out) #!N 08 
{ #!N 09 Object o = NULL, pickfield; #!N 10 char 
*colorstring; #!N 11 int colorwhich, poke, pick, depth; #!N 12 RGBColor 
color; #!EF #!N #!N #!EC #!N #!N #!N #!N Copy the 
structure of  #!F-adobe-times-bold-r-normal--18*   in[0] #!EF , the object in which picking 
took place. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 13 if (!in[0]) { 
#!N 14 DXSetError(ERROR_BAD_PARAMETER, "missing input"); #!N 15 goto error; #!N 16 
} #!N 17 o = (Object)DXCopy(in[0], COPY_STRUCTURE); #!N 18 if (!o) 
#!N 19 goto error; #!EF #!N #!N #!EC #!N #!N First, 
set all the colors to white, to initialize. (The SetColor routine 
is defined below.) #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 20 if (!SetColor(o, 
DXRGB(1.0, 1.0, 1.0))) #!N 21 goto error; #!EF #!N #!N #!EC 
#!N #!N  #!F-adobe-times-bold-r-normal--18*   in[1] #!EF is the pick Field. If the 
pick Field is  #!F-adobe-times-bold-r-normal--18*   NULL #!EF or an empty Field, just 
return the copy of the object. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 
22 if (!in[1] || DXEmptyField(in[1])) { #!N 23 out[0] = o; 
#!N 24 return OK; #!N 25 } #!N 26 pickfield = 
in[1]; #!EF #!N #!N #!EC #!N #!N Get the color that 
will be used for picked Objects, which is  #!F-adobe-times-bold-r-normal--18*   in[2] #!EF 
. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 27 if (in[2]) { #!N 
28 if (!DXExtractString((Object)in[2], &colorstring)) { #!N 29 DXSetError(ERROR_BAD_PARAMETER,"color must be a 
string"); #!N 30 goto error; #!N 31 } #!EF #!N #!N 
#!EC #!N #!N Convert the color name to an RGB vector. 
#!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 32 #!N 33 if (!DXColorNameToRGB(colorstring, &color)) 
#!N 34 goto error; #!N 35 } #!N 36 else { 
#!EF #!N #!N #!EC #!N #!N If  #!F-adobe-times-bold-r-normal--18*   in[2] #!EF is 
not specified, then the default color is red. #!CForestGreen #!N #!N 
 #!F-adobe-courier-bold-r-normal--18*   #!N 37 color = DXRGB(1.0, 0.0, 0.0); #!N 38 } 
#!EF #!N #!N #!EC #!N #!N Determine if we are to 
color just the picked element, just the vertex closest to the 
picked point, or the entire Field. The default is to color 
just the picked element. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 39 if 
(!in[3]) { #!N 40 colorwhich = 0; #!N 41 } #!N 
42 else { #!N 43 if (!DXExtractInteger(in[3], &colorwhich)) { #!N 44 
DXSetError(ERROR_BAD_PARAMETER,"colorwhich flag must be 0, 1, or 2"); #!N 45 goto 
error; #!N 46 } #!N 47 if ((colorwhich < 0)&&(colorwhich > 
2)) { #!N 48 DXSetError(ERROR_BAD_PARAMETER,"colorwhich flag must be 0, 1, or 
2"); #!N 49 goto error; #!N 50 } #!N 51 } 
#!EF #!N #!N #!EC #!N #!N Determine if we are to 
select a particular poke, or all of them. The default is 
to select all of them. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 52 
#!N 53 if (!in[4]) { #!N 54 poke = -1; #!N 
55 } #!N 56 else { #!N 57 if (!DXExtractInteger(in[4], &poke)) 
{ #!N 58 DXSetError(ERROR_BAD_PARAMETER,"poke must be a nonnegative integer"); #!N 59 
goto error; #!N 60 } #!N 61 if (poke < 0) 
{ #!N 62 DXSetError(ERROR_BAD_PARAMETER,"poke must be a nonnegative integer"); #!N 63 
goto error; #!N 64 } #!N 65 } #!EF #!N #!N 
#!EC #!N #!N Determine if we are to select a particular 
pick, or all of them. The default is to select all 
of them. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 66 if (!in[5]) { 
#!N 67 pick = -1; #!N 68 } #!N 69 else 
{ #!N 70 if (!DXExtractInteger(in[5], &pick)) { #!N 71 DXSetError(ERROR_BAD_PARAMETER,"pick must 
be a nonnegative integer"); #!N 72 goto error; #!N 73 } 
#!N 74 if (pick < 0) { #!N 75 DXSetError(ERROR_BAD_PARAMETER,"pick must 
be a nonnegative integer"); #!N 76 goto error; #!N 77 } 
#!N 78 } #!EF #!N #!N #!EC #!N #!N Determine if 
we are to select a depth. The default is to select 
the deepest level. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 79 if (!in[6]) 
{ #!N 80 depth = -1; #!N 81 } #!N 82 
else { #!N 83 if (!DXExtractInteger(in[6], &depth)) { #!N 84 DXSetError(ERROR_BAD_PARAMETER,"depth 
must be a nonnegative integer"); #!N 85 goto error; #!N 86 
} #!N 87 if (depth < 0) { #!N 88 DXSetError(ERROR_BAD_PARAMETER,"depth 
must be a nonnegative integer"); #!N 89 goto error; #!N 90 
} #!N 91 } #!EF #!N #!N #!EC #!N #!N Traverse 
the picked object, using the pick structure, passing the given parameters. 
#!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 92 if (!DoPick(o, pickfield, color, colorwhich, 
poke, pick, depth)) #!N 93 goto error; #!EF #!N #!N #!EC 
#!N #!N Delete the  #!F-adobe-times-bold-r-normal--18*   opacities #!EF component. #!CForestGreen #!N #!N 
 #!F-adobe-courier-bold-r-normal--18*   #!N 94 if (DXExists(o, "opacities")) #!N 95 DXRemove(o,"opacities"); #!EF #!N 
#!N #!EC #!N #!N Successful return. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 
96 out[0] = o; #!N 97 return OK; #!EF #!N #!N 
#!EC #!N #!N Return on error. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 
98 error: #!N 99 DXDelete(o); #!N 100 return ERROR; #!N 101 
} #!EF #!N #!N #!EC #!N #!N The  #!F-adobe-times-bold-r-normal--18*   DoPick() #!EF 
routine traverses the picked object. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 102 
static #!N 103 Error #!N 104 DoPick(Object o, Object pickfield, RGBColor 
color, int colorwhich, #!N 105 int pokes, int picks, int depth) 
#!N 106 { #!N 107 int pokecount, pickcount, poke, pick, i, 
pathlength; #!N 108 int vertexid, elementid, *path, numitems, index; #!N 109 
Object current; #!N 110 Matrix matrix; #!N 111 Array a, newcolors=NULL, 
oldcolors; #!N 112 char *depatt; #!N 113 RGBColor *newcolors_ptr, oldcolor; #!N 
114 int pokemin, pokemax; #!N 115 int pickmin, pickmax; #!N 116 
int thisdepth; #!EF #!N #!N #!EC #!N #!N  #!F-adobe-times-bold-r-normal--18*   pickfield #!EF 
is expected to be a Field. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 
117 if (!(DXGetObjectClass(pickfield)==CLASS_FIELD)) { #!N 118 DXSetError(ERROR_INVALID_DATA,"pickfield must be a field"); 
#!N 119 goto error; #!N 120 } #!EF #!N #!N #!EC 
#!N #!N Find out the number of pokes. #!CForestGreen #!N #!N 
 #!F-adobe-courier-bold-r-normal--18*   #!N 121 DXQueryPokeCount(pickfield, &pokecount); #!EF #!N #!N #!EC #!N #!N 
The user has chosen to mark all pokes. #!CForestGreen #!N #!N 
 #!F-adobe-courier-bold-r-normal--18*   #!N 122 if (pokes < 0) { #!N 123 pokemin 
= 0, pokemax = pokecount-1; #!N 124 } #!EF #!N #!N 
#!EC #!N #!N The user has specified a poke larger than 
the number present. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 125 else if 
(pokes > pokecount-1) { #!N 126 DXSetError(ERROR_BAD_PARAMETER, #!N 127 "only %d 
pokes are present", pokecount); #!N 128 return ERROR; #!N 129 } 
#!EF #!N #!N #!EC #!N #!N Consider only the specified poke. 
#!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 130 else #!N 131 pokemin = 
pokemax = pokes; #!EF #!N #!N #!EC #!N #!N For each 
poke... #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 132 for (poke=pokemin; poke<=pokemax; poke++) 
{ #!EF #!N #!N #!EC #!N #!N Find out how many 
picks there are in this poke. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 
133 if (!DXQueryPickCount(pickfield, poke, &pickcount)) #!N 134 goto error; #!EF #!N 
#!N #!EC #!N #!N Issue warning if this particular poke does 
not contain as many picks as the user has specified. #!CForestGreen 
#!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 135 if (picks > pickcount-1) { #!N 
136 DXWarning("poke %d contains only %d picks", poke, pickcount); #!N 137 
} #!N 138 #!N 139 else { #!N 140 if (picks 
< 0) { #!N 141 pickmin = 0, pickmax = pickcount-1; 
#!N 142 } #!N 143 else { #!N 144 pickmin = 
pickmax = picks; #!N 145 } #!EF #!N #!N #!EC #!N 
#!N For each pick... #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 146 #!N 
147 for (pick=pickmin; pick<=pickmax; pick++) { #!EF #!N #!N #!EC #!N 
#!N For the given  #!F-adobe-times-bold-r-normal--18*   pickfield #!EF , the current poke 
number, and the current pick number, get the traversal path  #!F-adobe-times-bold-r-normal--18*   
path #!EF , the length of the traversal path  #!F-adobe-times-bold-r-normal--18*   pathlength 
#!EF , and the IDs of the picked element and the 
picked vertex. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 148 DXQueryPickPath(pickfield, poke, pick, 
&pathlength, &path, #!N 149 &elementid, &vertexid); #!EF #!N #!N #!EC #!N 
#!N Initialize  #!F-adobe-times-bold-r-normal--18*   current #!EF to the picked object, and  #!F-adobe-times-bold-r-normal--18*   
matrix #!EF to the identity matrix. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 
150 current = o; #!N 151 matrix = Identity; #!N 152 
if (depth != -1 && pathlength > depth) #!N 153 thisdepth 
= depth; #!N 154 else #!N 155 thisdepth = pathlength; #!EF 
#!N #!N #!EC #!N #!N Iterate through the pick path. #!CForestGreen 
#!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 156 for (i=0; i<thisdepth; i++) { #!N 
157 current = DXTraversePickPath(current, path[i], &matrix); #!N 158 if (!current) #!N 
159 goto error; #!N 160 } #!EF #!N #!N #!EC #!N 
#!N  #!F-adobe-times-bold-r-normal--18*   current #!EF is now the Field level of the 
picked Object, and we have the element and vertex IDs of 
the picked object. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 161 if (colorwhich 
== 2 || DXGetObjectClass(current) != CLASS_FIELD) { #!EF #!N #!N #!EC 
#!N #!N We are simply to color the entire Field. #!CForestGreen 
#!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 162 if (!SetColor(current, color)) #!N 163 goto 
error; #!N 164 } #!N 165 else { #!EF #!N #!N 
#!EC #!N #!N Otherwise, we want to set the indicated element 
or vertex to the given color. We start by making a 
new colors component (not compact), but only if the input colors 
component is still compact. If it is already expanded, then modify 
it. #!N #!N First, determine the dependency of the colors. #!CForestGreen 
#!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 166 if (colorwhich == 0) { #!N 
167 if (a = DXGetComponentValue(current, "connections")) { #!N 168 index = 
elementid; #!N 169 depatt = "connections"; #!N 170 } #!N 171 
else if (a = DXGetComponentValue(current, "faces")) { #!N 172 index = 
elementid; #!N 173 depatt = "faces"; #!N 174 } #!N 175 
else { #!N 176 a = DXGetComponentValue(current, "positions"); #!N 177 index 
= vertexid; #!N 178 depatt = "positions"; #!N 179 } #!N 
180 } #!N 181 else { #!N 182 a = DXGetComponentValue(current, 
"positions"); #!N 183 index = vertexid; #!N 184 depatt = "positions"; 
#!N 185 } #!EF #!N #!N #!EC #!N #!N Determine the 
number of items. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 186 if (!DXGetArrayInfo(a, 
&numitems,NULL,NULL,NULL,NULL)) #!N 187 goto error; #!EF #!N #!N #!EC #!N #!N 
If the traversal index is greater than the number of items, 
something is wrong. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 188 if (index 
>= numitems) { #!N 189 DXSetError(ERROR_INVALID_DATA, #!N 190 "pick structure does 
not correspond to picked object"); #!N 191 goto error; #!N 192 
} #!EF #!N #!N #!EC #!N #!N Get the original colors 
component. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 193 oldcolors = DXGetComponentValue((Field)current, "colors"); 
#!EF #!N #!N #!EC #!N #!N If it is a constant 
Array, we need to expand it so that we can set 
just one element or vertex to the given color. #!CForestGreen #!N 
#!N  #!F-adobe-courier-bold-r-normal--18*   #!N 194 if (DXQueryConstantArray(oldcolors, NULL, &oldcolor)) { #!EF #!N 
#!N #!EC #!N #!N Create a new colors Array and allocate 
space to it. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 195 newcolors = 
DXNewArray(TYPE_FLOAT,CATEGORY_REAL, 1, 3); #!N 196 if (!DXAddArrayData(newcolors, 0, numitems, NULL)) #!N 
197 goto error; #!EF #!N #!N #!EC #!N #!N Start by 
setting all colors to the original constant color. #!CForestGreen #!N #!N 
 #!F-adobe-courier-bold-r-normal--18*   #!N 198 newcolors_ptr = (RGBColor *)DXGetArrayData(newcolors); #!N 199 for (i=0; 
i<numitems; i++) { #!N 200 newcolors_ptr[i] = oldcolor; #!N 201 } 
#!EF #!N #!N #!EC #!N #!N Replace the colors in the 
Field with the new colors component. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 
202 if (!DXSetComponentValue((Field)current, "colors", #!N 203 (Object)newcolors)) #!N 204 goto error; 
#!N 205 newcolors=NULL; #!N 206 #!N 207 DXSetComponentAttribute((Field)current, "colors", "dep", #!N 
208 (Object)DXNewString(depatt)); #!N 209 } #!N 210 #!N 211 #!N 212 
else { #!EF #!N #!N #!EC #!N #!N The colors are 
already expanded, presumably from an earlier pick in this Field. #!CForestGreen 
#!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 213 newcolors_ptr = (RGBColor *)DXGetArrayData(oldcolors); #!N 214 
} #!EF #!N #!N #!EC #!N #!N Set the correct triangle 
or position to the given color. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 
215 newcolors_ptr[index] = color; #!N 216 } #!N 217 } #!N 
218 } #!N 219 } #!N 220 #!N 221 return OK; 
#!N 222 #!N 223 error: #!N 224 DXDelete((Object)newcolors); #!N 225 return 
ERROR; #!N 226 } #!EF #!N #!N #!EC #!N #!N This 
routine sets all colors in object  #!F-adobe-times-bold-r-normal--18*   o #!EF to the 
given color. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 227 static Error SetColor(Object 
o, RGBColor color) #!N 228 { #!N 229 Object subo; #!N 
230 Array a, newcolors=NULL; #!N 231 int numitems, i; #!N 232 
#!N 233 #!N 234 switch (DXGetObjectClass(o)) { #!N 235 #!N 236 
#!N 237 case (CLASS_GROUP): #!N 238 #!EF #!N #!N #!EC #!N 
#!N If  #!F-adobe-times-bold-r-normal--18*   o #!EF is a Group, call  #!F-adobe-times-bold-r-normal--18*   SetColor 
#!EF recursively on its children. #!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 239 
for (i=0; subo = DXGetEnumeratedMember((Group)o, i, NULL); i++)) #!N 240 SetColor(subo, 
color); #!N 241 break; #!N 242 #!N 243 #!N 244 case 
(CLASS_XFORM): #!EF #!N #!N #!EC #!N #!N If  #!F-adobe-times-bold-r-normal--18*   o #!EF 
is an Xform, call  #!F-adobe-times-bold-r-normal--18*   SetColor #!EF on its child. #!CForestGreen 
#!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 245 DXGetXformInfo((Xform)o, &subo, NULL); #!N 246 SetColor(subo, 
color); #!N 247 break; #!N 248 #!N 249 #!N 250 case 
(CLASS_CLIPPED): #!EF #!N #!N #!EC #!N #!N If  #!F-adobe-times-bold-r-normal--18*   o #!EF 
is a Clipped object, call  #!F-adobe-times-bold-r-normal--18*   SetColor #!EF on its child. 
#!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 251 DXGetClippedInfo((Clipped)o, &subo, NULL); #!N 252 
SetColor(subo, color); #!N 253 break; #!N 254 #!N 255 #!N 256 
case (CLASS_FIELD): #!EF #!N #!N #!EC #!N #!N If  #!F-adobe-times-bold-r-normal--18*   o 
#!EF is a Field, set the colors to the given color. 
#!CForestGreen #!N #!N  #!F-adobe-courier-bold-r-normal--18*   #!N 257 if (DXEmptyField((Field)o)) #!N 258 return 
OK; #!EF #!N #!N #!EC #!N #!N The number of colors 
and the dependency of the colors will depend on whether connections 
are present. If not, it is checked for the presence of 
faces. Otherwise, the colors will be dependent on positions. #!CForestGreen #!N 
#!N  #!F-adobe-courier-bold-r-normal--18*   #!N 259 if (a = DXGetComponentValue((Field)o, "connections")) { #!N 
260 DXGetArrayInfo(a, &numitems, NULL, NULL, NULL, NULL); #!N 261 newcolors = 
(Array)DXNewConstantArray(numitems, &color, #!N 262 TYPE_FLOAT, #!N 263 CATEGORY_REAL, 1, 3); #!N 
264 DXSetComponentValue((Field)o, "colors", (Object)newcolors); #!N 265 newcolors = NULL; #!N 266 
DXSetComponentAttribute((Field)o,"colors", "dep", #!N 267 (Object)DXNewString("connections")); #!N 268 } #!N 269 else 
if (a = DXGetComponentValue((Field)o, "faces")) { #!N 270 DXGetArrayInfo(a, &numitems, NULL, 
NULL, NULL, NULL); #!N 271 newcolors = (Array)DXNewConstantArray(numitems, &color, #!N 272 
TYPE_FLOAT, #!N 273 CATEGORY_REAL, 1, 3); #!N 274 DXSetComponentValue((Field)o, "colors", (Object)newcolors); 
#!N 275 newcolors = NULL; #!N 276 DXSetComponentAttribute((Field)o,"colors", "dep", #!N 277 
(Object)DXNewString("faces")); #!N 278 } #!EF #!N #!N #!EC #!CForestGreen #!N #!N 
 #!F-adobe-courier-bold-r-normal--18*   #!N 279 else { #!N 280 a = DXGetComponentValue((Field)o, "positions"); 
#!N 281 DXGetArrayInfo(a, &numitems, NULL, NULL, NULL, NULL); #!N 282 newcolors 
= (Array)DXNewConstantArray(numitems, &color, #!N 283 TYPE_FLOAT, #!N 284 CATEGORY_REAL, 1, 3); 
#!N 285 DXSetComponentValue((Field)o, "colors", (Object)newcolors); #!N 286 newcolors = NULL; #!N 
287 DXSetComponentAttribute((Field)o,"colors", "dep", #!N 288 (Object)DXNewString("positions")); #!N 289 } #!N 290 
#!N 291 break; #!N 292 } #!N 293 #!EF #!N #!N 
#!EC #!N #!N Successful return or return on error. #!CForestGreen #!N 
#!N  #!F-adobe-courier-bold-r-normal--18*   #!N 294 #!N 295 return OK; #!N 296 error: 
#!N 297 DXDelete((Object)newcolors); #!N 298 return ERROR; #!N 299 } #!EF 
#!N #!N #!EC #!N #!N #!N  #!F-adobe-times-medium-i-normal--18*   Next Topic #!EF #!N 
#!N  #!Lparal,dxall1042 h Writing Modules for a Parallel Environment  #!EL  #!N  #!F-adobe-times-medium-i-normal--18*   #!N 
